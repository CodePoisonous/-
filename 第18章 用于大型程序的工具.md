# 第18章 用于大型程序的工具

## 18.1 异常处理

1. **异常处理（exception handing）** 机制允许程序中独立开发的部分能够在运行时就出现的问题进行通信并做出相应的处理。

### 18.1.1 抛出异常

1. 通过**抛出（throwing）** 一条表达式来**引发（raised）**一个异常。
2. 被抛出表达式的类型以及当前的调用链共同决定了哪段**处理代码（handling）** 将被用于处理该异常。
3. 当执行一个`throw`时，跟在`throw`后面的语句将不再执行，然后进行**栈展开（stack unwinding）**。栈展开过程沿着嵌套函数的调用链不断查找，直到找到了异常匹配的`catch`子句为止；或者也可能一直没找到匹配的`catch`，程序将调用标准库函数`terminate`终止程序的执行
4. 类对象分配的资源将由类的析构函数负责释放。因此，如果我们使用类来控制资源的分配，就能确保无论函数正常结束还是遭遇异常，资源都能被正确地释放。
5. 出于栈展开可能使用析构函数的考虑，析构函数不应该抛出不能被它自身处理的异常。如果析构函数需要执行某个可能抛出异常的操作，则该操作应该被放置在一个`try`语句块当中，并且在析构函数内部得到处理。
6. **异常对象（exception object）**是一种特殊的对象，编译器使用异常抛出表达式来对异常对象进行拷贝初始化。因此，`throw`语句中的表达式必须拥有完全类型。当我们抛出表达式时，该表达式的静态编译时类型决定了异常对象的类型。
7. 抛出指针要求在任何对应的处理代码存在的地方，指针所指的对象都必须存在。

### 18.1.2 捕获异常

### 18.1.3 函数`try`语句块与构造函数

### 18.1.4 `noexcept`异常说明

### 18.1.5 异常类层次

----

## 18.2 命名空间

### 18.2.1 命名空间定义

### 18.2.2 使用命名空间成员

### 18.2.3 类、命名空间与作用域

### 18.2.4 重载与命名空间

----

## 18.3 多重继承与虚继承

### 18.3.1 多重继承

### 18.3.2 类型转换与多个基类

### 18.3.3 多重继承下的类作用域

### 18.3.4 虚继承

### 18.3.5 构造函数与虚继承
