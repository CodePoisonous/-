# 第18章 用于大型程序的工具

## 18.1 异常处理

1. **异常处理（exception handing）** 机制允许程序中独立开发的部分能够在运行时就出现的问题进行通信并做出相应的处理。

### 18.1.1 抛出异常

1. 通过**抛出（throwing）** 一条表达式来**引发（raised）**一个异常。
2. 被抛出表达式的类型以及当前的调用链共同决定了哪段**处理代码（handling）** 将被用于处理该异常。
3. 当执行一个`throw`时，跟在`throw`后面的语句将不再执行，然后进行**栈展开（stack unwinding）**。栈展开过程沿着嵌套函数的调用链不断查找，直到找到了异常匹配的`catch`子句为止；或者也可能一直没找到匹配的`catch`，程序将调用标准库函数`terminate`终止程序的执行
4. 类对象分配的资源将由类的析构函数负责释放。因此，如果我们使用类来控制资源的分配，就能确保无论函数正常结束还是遭遇异常，资源都能被正确地释放。
5. 出于栈展开可能使用析构函数的考虑，析构函数不应该抛出不能被它自身处理的异常。如果析构函数需要执行某个可能抛出异常的操作，则该操作应该被放置在一个`try`语句块当中，并且在析构函数内部得到处理。
6. **异常对象（exception object）**是一种特殊的对象，编译器使用异常抛出表达式来对异常对象进行拷贝初始化。因此，`throw`语句中的表达式必须拥有完全类型。当我们抛出表达式时，该表达式的静态编译时类型决定了异常对象的类型。
7. 抛出指针要求在任何对应的处理代码存在的地方，指针所指的对象都必须存在。

### 18.1.2 捕获异常

1. **catch子句（catch clause）** 中的 **异常声明（exception declaration）** 看起来像是只包含一个形参的函数形参列表。像在形参列表中一样，如果 `catch` 无须访问抛出的表达式的话，则我们可以忽略捕获形参的名字。
2. 通常情况下，如果`catch`接受的异常与某个继承体系有关，则最好将该`catch`的参数定义成引用类型。
3. 如果在多个`catch`语句的类型之间存在着继承关系，则我们应该把继承链最底端的类（most derived type）放在前面，而将继承链最顶端的类（least derived type）放在后面。
4. 一条`catch`语句通过**重新抛出（rethrowing）**的操作将异常传递给另一个`catch`语句。这里的重新抛出仍然是一条`throw`语句，只不过不包含任何表达式。
5. 为了一次性捕获所有异常，我们使用省略号作为异常声明，这样的处理代码称为**捕获所有异常（catch-all）** 的处理代码，形如 `catch(...)`。
6. 如果`catch(...)`与其他几个`catch`语句一起出现，则`catch(...)`必须在最后的位置。出现在捕获所有异常语句后面的`catch`语句将永远不被匹配。

### 18.1.3 函数`try`语句块与构造函数

1. 要想处理**构造函数初始值**抛出的异常，我们必须将构造函数写成**函数try语句块**（也称为函数测试块，function try block）的形式。
2. 函数`try`语句块使得一组`catch`语句既能处理构造函数体（或析构函数），也能处理构造函数的初始化过程（或析构函数的析构过程）。

```c++
tempalte <typename T>
Blob<T>::Blob(std::initializer_list<T> il) try :
    data(std::make_shared<std::vector<T>>(il)) {
        // 函数载体
} catch(const std::bad_alloc& e) { handle_out_of_memory(e); }
```

3. 和其他函数调用一样，如果在参数初始化的过程中发生了异常，则该异常属于调用表达式的一部分，并将在调用者所在的上下文中处理。
4. 处理构造函数初始值异常的唯一方法是将构造函数写成函数`try`语句块。

### 18.1.4 `noexcept`异常说明

1. c++11新标准中，可以通过提供**noexcept说明（noexcept specification）** 指定某个函数不会抛出异常。

```c++
void recoup(int) noexcept;  // 不会抛出异常
void alloc(int);            // 可能会抛出异常

void recoup(int) noexcept(true);    // 不会抛出异常
void alloc(int) noexcept(false);    // 可能抛出异常
```

2. `noexcept`说明要么出现在该函数的所有声明语句和定义语句中，要么一次也不出现。
3. 编译器不会在编译时检查`noexcept`说明。如果一个函数在说明了`noexcept`的同时又含有`throw`语句或者调用了可能抛出异常的其他函数，编译器将顺利编译通过，并不会因为这种违反异常说明的情况而报错。

```c++
void f() noexcept(noexcept(g()));   // f和g的异常说明一致

// noexcept有两层含义：
// 当跟在函数参数列表后面时它是异常说明符；
// 而当作为noexcept异常说明的bool实参出现时，它是一个运算符。
```

4. 函数指针及该指针所指的函数必须具有一致的异常说明。
5. 如果一个虚函数承诺了它不会抛出异常，则后续派生出来的虚函数也必须做出同样的承诺；与之相反，如果基类的虚函数允许抛出异常，则派生类的对应函数既可以允许抛出异常，也可以不允许抛出异常。

----

## 18.2 命名空间

### 18.2.1 命名空间定义

### 18.2.2 使用命名空间成员

### 18.2.3 类、命名空间与作用域

### 18.2.4 重载与命名空间

----

## 18.3 多重继承与虚继承

### 18.3.1 多重继承

### 18.3.2 类型转换与多个基类

### 18.3.3 多重继承下的类作用域

### 18.3.4 虚继承

### 18.3.5 构造函数与虚继承
