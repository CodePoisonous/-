# 第17章 特殊库特殊设施

## 17.1 `tuple`类型

1. 我们可以将`tuple`看作一个“快速而随意”的数据结构。可以有任意数量的成员，且成员的类型不受限制。

### 17.1.1 定义和初始化`tuple`

1. 当我们创建一个`tuple`时，需要指出每个成员的类型。
2. 创建一个`tuple`对象时，可以使用它的默认构造函数，它会对每个成员进行值初始化。
3. 当使用初始值初始化对象时，构造函数是`explicit`。因此必须使用直接初始化语法：

```c++
tuple<size_t, int, double> item = {1, 2, 3.0}; // 错误
tuple<size_t, int, double> item(1, 2, 3.0);    // 正确

// 如果不知道tuple准确的类型细节信息，
// 可以用两个辅助类模板来查询tuple成员的数量和类型
typedef decltype(item) trans;// trans是item的类型

// 返回trans类型对象中成员的数量：
size_t sz = tuple_size<trans>::value;   // 返回3
// cnt的类型与item中第二个成员相同
tuple_element<1, trans>::type cnt = get<1>(item);   // cnt是一个int
```

4. 由于`tuple`定义了 < 和 == 运算符，我们可以将`tuple`序列传递给算法，并且可以在无序容器中将`tuple`作为关键字类型。

----

## 17.2 `bitset`类型

### 17.2.1 定义和初始化`bitset`

1. 定义一个`bitset`需要声明它包含多好个二进制位。
2. `string`的下标编号习惯与`bitset`恰好相反：`string`中下标最大的字符（最右字符）用来初始化`bitset`中的低位（下标为0的二进制位）。

### 17.2.2 `bitset`操作

1. 编写一个程序表示30给学生的测试结果-“通过/失败”

```c++
bool status;

// 使用位运算符的版本
unsigned long quizA = 0;     // 此值被当作位集合使用
quizA |= 1UL << 27;          // 指出第27个学生通过了测试
status = quizA & (1UL << 27);// 检查第27个学生是否通过了测验
quizA &= ~(1UL << 27);       // 第27个学生未通过测验

// 使用标准库bitset完成等价的工作
bitset<30> quizB;           // 每个学生分配一位，所有位都被初始化为0
quizB.set(27);              // 指出第27个学生通过了测试
status = quizB[27];         // 检查第27个学生是否通过了测验
quizB.reset(27);            // 第27个学生未通过测验
```

----

## 17.3 正则表达式

### 17.3.1 使用正则表达式库

### 17.3.2 匹配与`Regex`迭代器类型

### 17.3.3 使用子表达式

----

## 17.4 随机数

### 17.4.1 随机数引擎和分布

### 17.4.2 其他随机数分布

----

## 17.5 `IO`库再探

### 17.5.1 格式化输入和输出

### 17.5.2 未格式化的输入/输出操作

### 17.5.3 流随机访问