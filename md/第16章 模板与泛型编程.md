# 第16章 模板与泛型编程

----

## 16.1 定义模板

### 16.1.1 函数模板

1. 我们可以定义一个通用的**函数模板（function template）**，而不是为每个类型都定义一个新函数。一个函数模板就是一个公式，可用来生成针对特定类型的函数版本。
2. 模板定义以关键字`template`开始，后跟一个**模板参数列表（template parameter list）**，模板参数列表不能为空。

```c++
template <typename T>
int compare(const T& v1, const T& v2)
{
    if(v1 < v2) return -1;
    if(v1 > v2) return 1;
    return 0;
}
```

3. 编译器用推断出的模板参数来为我们**实例化（instantiate）**一个特定版本的函数。使用模板实参代替对应的模板参数来创建出模板的一个新"实例"。
4. 我们可以将**类型参数（type parameter）**看作类型说明符，就像内置类型或类类型说明符一样使用。
5. 类型参数可以用来指定返回类型或函数的参数类型，以及在函数体内用于变量声明或类型转换：

```c++
// 类型参数为 T
template <typename T> T foo(T* p)
{
    T tmp = *p;
    // ... 
    return tmp;
}
```

6. 除了定义类型参数，还可以在模板中定义**非类型参数（nontype parameter）**。一个非类型参数表示一个值而非一个类型。通过一个**特定的类型名**而非关键字`class`或`typename`来指定非类型参数。
7. 当一个模板被实例化时，非类型参数被一个用户提供的或编译器推断出的值所代替。这些值必须是常量表达式，从而允许编译器在编译时实例化模板。
8. 一个非类型参数可以是一个整型，或者是一个指向对象或函数类型的指针或（左值）引用。
9. 绑定到非类型整型参数的实参必须是一个常量表达式。绑定到指针或引用的非类型参数的实参必须具有静态的生存期。
10. 不能用一个普通（非`static`）局部变量或动态对象作为指针或引用非类型模板参数的实参。指针参数也可以用`nullptr`或一个值为0的常量表达式来实例化。

```c++
template <unsigned N, unsigned M>
int compare(const char (&p1)[N], const char (&p2)[M])
{
    return strcmp(p1, p2);
}

// 调用模板：
compare("hi", "mom");

// 模板将会实例化成：
int compare(const char (&p1)[3], const char (&p2)[4])
```

11. 模板程序应该尽量减少对实参类型的要求。
12. 函数模板和类模板成员函数的定义通常放在头文件中。
13. 大多数编译错误在实例化期间报告。
14. 保证传递给模板的实参支持模板所要求的操作，以及这些操作在模板中能正确工作，是调用者的责任。

### 16.1.2 类模板

1. **类模板（class template）是用来生成类的蓝图的。
2. 与函数模板的不同之处是，编译器不能为类模板推断模板参数类型。为了使用类模板，我们必须在模板名后的尖括号中提供额外信息-用来代替模板参数的模板实参列表。
3. 使用模板时，需要提供显式模板实参（explicit template argument）列表作为额外信息，它们被绑定到模板参数。编译器使用这些模板参数来实例化特定的类。

```c++
template <typename T> class Blob {
public:
    Blob();
    Blob(std::initializer_list<T> il);
    // ... ...
private:
    std::shared_ptr<std::vector<T>> data;
    // ... ...
}

Blob<int> ia;               // 空Blob<int>
Blob<int> ia2 = {0, 1, 2}   // 有3个元素的Blob<int>

// 编译器会实例化出一个与下面定义等价的类：
template <> class Blob<int> {
public:
    Blob();
    Blob(std::initializer_list<int> il);
    // ... ...
private:
    std::shared_ptr<std::vector<int>> data;
    // ... ...
}
```

4. 一个类模板的每个实例都形成一个独立的类。类型`Blob<string>`与任何其他的`Blob`类型都没有关联，也不会对其他任何`Blob`类型的成员有特殊访问权限。
5. 默认情况下，对于一个实例化了的类模板，其成员只有在使用时才被实例化。这一特征是的即使某种类型不能完全符合模板操作的要求，我们仍然能用该类型实例化类。
6. 在类模板自己的作用域内，可以直接使用模板名而不提供实参，编译器处理模板自身的引用时就好像我们已经提供了与模板参数匹配的实参一样。
7. 当我们在类模板外定义其他成员时，必须记住，我们并不在类的作用域中，直到遇到类名才表示进入类的作用域。
8. 当一个类包含一个友元声明时，类与友元各自是否是模板是相互无关的。
9. 如果一个类模板包含一个非模板友元，则友元被授权可以访问所有模板实例。如果友元自身是模板，类可以授权给所有友元模板实例，也可以只授权给特定实例。
10. 模板类与另一个（类或函数）模板间友好关系的最常见的形式是建立对应实例及其友元间的友好关系。
11. 一个类也可以将另一个模板的每一个实例都声明为自己的友元，或者限定特定的实例为友元。
12. 在新标准中，可以令模板自己的类型参数成为友元：

```c++
template <typename Type> class Bar{
    friend Type;    // 将访问权限授予用来实例化Bar的类型
    // ...
}
```

13. 类模板的一个实例定义了一个类类型，与任何其他类类型一样，我们可以定义一个`typedef`来引用实例化的类：

```c++
typedef Blob<string> StrBlob;

// 由于模板不是类型，我们无法定义一个typedef引用一个模板：
typedef Blob<T> TBlob;

// 新标准允许我们为类模板定义一个类型别名：
template <typename T> using twin = pair<T, T>;
twin<string> authors;   // 一个pair<string, string>

// 可以固定一个或多个模板参数
template <typename T> using partNo = pair<T, unsigned>;
partNo<string> books;   // 一个pair<string, unsigned>
```

14. 类模板可以声明`static`成员。
15. 类似任何其他的成员函数，一个static成员函数只有在使用时才会实例化。

```c++
template <typename T> class Foo {
public:
    static std::size_t count() { return ctr; }
private:
    static std::size_t ctr;
};

// 将static数据成员也定义为模板
template <typename T>
size_t Foo<T>::ctr = 0; // 定义并初始化ctr

// 访问静态成员函数：
Foo<int> fi;                 // 实例化Foo<int>类和static数据成员ctr
auto ct = Foo<int>::count(); // 实例化Foo<int>::count
ct = fi.count();             // 使用Foo<int>::count
ct = Foo::count();           // 错误：使用哪个模板实例的count？
```

### 16.1.3 模板参数

1. 一个模板参数名的可用范围是在其声明之后，至模板声明或定义结束之前。
2. 与其他任何名字一样，模板参数会隐藏外层作用域中声明的相同名字。但是，与大多数其他上下文不同，在模板内不能重用模板参数名：

```c++
typedef double A;
template <typename A, typename B> void f(A a, B b) {
    A tmp = a;  // tmp的类型为模板参数A的类型，为double
    double B;   // 错误：重声明模板参数B
}

// 由于参数名不能重用，所以一个模板参数名在一个特定模板参数列表中只能出现一次：
// 错误：非法重用模板参数名V
template <typename V, typename V> // ...
```

3. 一个特定文件所需要的所有模板的声明通常一起放置在文件开始位置，出现于任何使用这些模板的代码之前。
4. c++语言假定通过作用域运算符访问的名字不是类型。因此，如果我们希望使用一个模板类型参数的类型成员，就必须显式告诉编译器该名字是一个类型。我们通过关键字`typename`来实现这一点。
5. 当我们希望通知编译器一个名字表示类型时，必须使用关键字`typename`，而不能使用`class`。

```c++
template <typename T>
typename T::value_type top(const T& c) {
    if(!c.empty()) return c.back();
    else return typename T::value_type();
}
```

6. 可以给函数的模板参数提供**默认实参（default template argument）。
7. 与函数默认实参一样，对于一个模板参数，只有当它右侧的所有参数都有默认实参时，它才可以有默认实参。

```c++
// compare有一个默认模板实参less<T>和一个默认函数实参F()
template <typename T, typename F = less<T>>
int compare(const T& v1, const T& v2, F f = F()) {
    if(f(v1, v2)) return -1;
    if(f(v2, v1)) return 1;
    return 0;
}
```

8. 无论何时使用一个类模板，我们都必须在模板名之后接上尖括号。尖括号指出类必须从一个模板实例化而来。
9. 特别是，如果一个类模板为其所有模板参数都提供了默认实参，且我们希望使用这些默认实参，就必须在模板名之后跟一个空尖括号对：

```c++
template <class T = int> class Numbers { // T默认为int
public:
    Numbers(T v = 0) : val { }
    // ...
private:
    T val;
};

Numbers<long long> a;   // 使用long long实例化类模板
Numbers<> b;            // 空<>表示希望使用默认类型(int)
```

### 16.1.4 成员模板

1. 一个类（无论是普通类还是类模板）可以包含本身是模板的成员函数。这些成员被称为**成员模板（member template）**。成员模板不能是虚函数。
2. 对于类模板，我们也可以为其定义成员模板。在此情况下，类和成员各自有自己的、独立的模板参数。

```c++
template <typename T> class Blob {
    template <typename It> Blob(It b, It e);
    // ...
}

// 与类模板的普通成员函数不同，成员模板是函数模板。
// 当我们在类模板外定义一个成员模板时，必须同时为类模板和成员模板提供模板参数列表。
// 类模板的参数列表在前，后跟成员自己的模板参数列表：
template <typename T>   // 类的类型参数
tempalte <typename It>  // 构造函数的类型参数
    Blob<T>::Blob(It b, It e): data(std::make_shared<std::vector<T>>(b, e)) {}
```

### 16.1.5 控制实例化

### 16.1.6 效率与灵活性

----

## 16.2 模板实参推断

### 16.2.1 类型转换与模板类型参数

### 16.2.2 函数模板显式实参

### 16.2.3 尾置返回类型与类型转换

### 16.2.4 函数指针和实参推断

### 16.2.5 模板实参推断和引用

### 16.2.6 理解 std::move

### 16.2.7 转发

----

## 16.3 重载与模板

----

## 16.4 可变参数模板

### 16.4.1 编写可变参数函数模板

### 16.4.2 包扩展

### 16.4.3 转发参数包

----

## 16.5 模板特例化
