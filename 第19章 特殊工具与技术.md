# 第19章 特殊工具与技术

## 19.1 控制内存分配

### 19.1.1 重载`new`和`delete`

1. new一个对象分三个步骤：
（1）`new`表达式调用名为`operator new`（或者`operator new[]`）的标准库函数。该函数分配一块足够大的、原始的、未命名的内存空间以便存储特定类型的对象（或者对象的数组）。
（2）编译器运行相应的构造函数以构造这些对象，并为其传入初始值。
（3）对象被分配了空间并构造完成，返回一个指向该对象的指针。
2. `delete`一个对象分两个步骤：
（1）调用对象的析构函数。
（2）编译器调用名为`operator delete`（或者`operator delete[]`）的标准库函数释放内存空间。
3. 如果应用程序希望控制内存分配的过程，则它们需要定义自己的`operator new`函数和`operator delete`函数。即使在标准库中已经存在这两个函数的定义，我们仍旧可以定义自己的版本。
4. 当自定义了全局的`operator new`函数和`operator delete`函数后，我们就负担起了控制动态内存分配的职责。这两个函数必须是正确的：因为它们是程序整个处理过程中至关重要的一部分。
5. 当我们将上述两个运算符函数定义成类的成员时，它们是**隐式静态的**，也必须是静态的。而且它们不能操纵类的任何数据成员。
6. 标准库函数`operator new`和`operator delete`的名字容易让人误解。和其他`operator`函数不同（比如`operator=`），这两个函数并没有重载`new`表达式和`delete`表达式。实际上，我们根本无法自定义`new`表达式或`delete`表达式的行为。
7. 我们提供新的`operator new`函数和`operator delete`函数的目的在于改变内存分配的方式，但是不管怎样，我们都不能改变`new`运算符和`delete`运算符的基本含义。

```c++
void* operator new(size_t size){
    if(void* mem = malloc(size))
        return mem;
    else
        throw bad_alloc();
}

void operator delete(void* mem) noexcept {
    free(mem);
}
```

----

## 19.2 运行时类型识别

### 19.2.1 `dynamic_cast`运算符

### 19.2.2 `typeid` 运算符

### 19.2.3 使用 `RTTI`

### 19.2.4 `type_info`类

----

## 19.3 枚举类型

----

## 19.4 类成员指针

### 19.4.1 数据成员指针

### 19.4.2 成员函数指针

### 19.4.3 将成员函数用作可调用对象  

----

## 19.5 嵌套类

----

## 19.6 `union`：一种节约空间的类

----

## 19.7 局部类

----

## 19.8 固有的不可移植的特性

### 19.8.1 位域

### 19.8.2 `volatile`限定符

### 19.8.3 链接指示：`extern "C"`
