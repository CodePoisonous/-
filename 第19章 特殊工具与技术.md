# 第19章 特殊工具与技术

## 19.1 控制内存分配

### 19.1.1 重载`new`和`delete`

1. new一个对象分三个步骤：
（1）`new`表达式调用名为`operator new`（或者`operator new[]`）的标准库函数。该函数分配一块足够大的、原始的、未命名的内存空间以便存储特定类型的对象（或者对象的数组）。
（2）编译器运行相应的构造函数以构造这些对象，并为其传入初始值。
（3）对象被分配了空间并构造完成，返回一个指向该对象的指针。
2. `delete`一个对象分两个步骤：
（1）调用对象的析构函数。
（2）编译器调用名为`operator delete`（或者`operator delete[]`）的标准库函数释放内存空间。
3. 如果应用程序希望控制内存分配的过程，则它们需要定义自己的`operator new`函数和`operator delete`函数。即使在标准库中已经存在这两个函数的定义，我们仍旧可以定义自己的版本。
4. 当自定义了全局的`operator new`函数和`operator delete`函数后，我们就负担起了控制动态内存分配的职责。这两个函数必须是正确的：因为它们是程序整个处理过程中至关重要的一部分。
5. 当我们将上述两个运算符函数定义成类的成员时，它们是**隐式静态的**，也必须是静态的。而且它们不能操纵类的任何数据成员。
6. 标准库函数`operator new`和`operator delete`的名字容易让人误解。和其他`operator`函数不同（比如`operator=`），这两个函数并没有重载`new`表达式和`delete`表达式。实际上，我们根本无法自定义`new`表达式或`delete`表达式的行为。
7. 我们提供新的`operator new`函数和`operator delete`函数的目的在于改变内存分配的方式，但是不管怎样，我们都不能改变`new`运算符和`delete`运算符的基本含义。

```c++
void* operator new(size_t size){
    if(void* mem = malloc(size))
        return mem;
    else
        throw bad_alloc();
}

void operator delete(void* mem) noexcept {
    free(mem);
}
```

----

## 19.2 运行时类型识别

1. **运行时类型识别(run-time type identification, RTTI)** 的功能由两个运算符实现：
（1）**type**运算符，用于返回表达式的类型。
（2）**dynamic_cast** 运算符，用于将基类的指针或引用安全地转换成派生类的指针或引用。
2. 程序员必须清楚地知道转换的目标类型并且必须检查类型转换是否被成功执行。
3. 使用RTTI必须要加倍小心。在可能的情况下，最好定义虚函数而非直接接管类型管理的重任。

### 19.2.1 `dynamic_cast`运算符

1. `dynamic_cast`运算符的使用形式：
`dynamic_cast<type*>(e)`
`dynamic_cast<type&>(e)`
`dynamic_cast<type&&>(e)`
2. 我们可以对一个空指针执行`dynamic_cast`，结果是所需类型的空指针。
3. 当引用的类型转换失败时，程序抛出一个名为`std::bad_cast`的异常：

```c++
 void f(const Base& b)
 {
    try {
        const Derived& d = dynamic_cast<const Derived&>(b);
    } catch (bad_cast) {
        // 处理类型转换失败的情况
    }
 }
```

### 19.2.2 `typeid` 运算符

1. `typeid`表达式的形式是`typeid(e)`，其中e可以是任意表达式或类型的名字。`type`操作的结果是一个常量对象的引用，该对象的类型是标准库类型`type_info`或 `type_info`的公有派生类型。

```c++
Derived* dp = new Derived;
Base* bp = dp;  // 两个指针都指向Derived对象;

// 在运行时比较两个对象的类型
if(typeid(*dp) == typeid(*bp)) {
    // dp 和 bp 指向同一类型的对象
}

//检查运行时类型是否是某种指定的类型
if(typeid(*bp) == typeid(Derived)) {
    // bp实际指向Derived对象
} 

// 注意，typeid应该作用与对象，因此我们使用*bp而非bp
// 下面的检查永远是失败的：bp的类型是指向Base的指针
if(typeid(bp) == typeid(Derived)) {
    // 此处的代码永远不会执行
}
```

2. 当 `typeid`作用于指针时（而非指针所指的对象），返回的结果是该指针的静态编译时类型。
3. 如果p是一个空指针，则`typeid(*p)`将抛出一个名为`bad_typeid`的异常。

### 19.2.4 `type_info`类

1. 创建`type_info`对象的唯一途径是使用`typeid`运算符。
2. 对于某种给定的类型来说，`name`的返回值因编译器而异并且不一定与在程序中使用的名字一致。对于`name`返回值的唯一要求是，类型不同则返回的字符串必须有所区别。
3. 有的编译器提供了额外的成员函数以提供程序中所用类型的额外信息。

----

## 19.3 枚举类型

1. **枚举类型（enumeration）** 使我们可以将一组整型常量组织在一起。和类一样，每个枚举类型定义了一种新的类型。枚举属于字面值常量类型。
2. c++包含两种枚举：限定作用域和不限定作用域的。
3. 在限定作用域的枚举类型中，枚举成员的名字遵循常规的作用域准则，并且在枚举类型的作用域外是不可访问的。与之相反，在不限定作用域的枚举类型中，枚举成员的作用域与枚举类型本身的作用域相同。
4. 枚举成员是`const`，因此在初始化枚举成员时提供的初始值必须是常量表达式。
5. 想要初始化`enum`对象或者为`enum`对象赋值，必须使用该类型的一个枚举成员或者该类型的另一个对象。
6. 即使某个整数值恰好与枚举成员的值相等，它也不能作为函数的`enum`实参使用。
7. c++11新标准中，我们可以在`enum`的名字后加上冒号以及我们想在该`enum`中使用的类型。
8. c++11新标准中，我们可以提前声明`enum`。`enum`的前置声明（无论隐式地还是显示地）必须指定其成员的大小。
9. `enum`的声明和定义必须匹配，这意味着在该`enum`的所有声明和定义中成员的大小必须一致。而且，我们不能在同一个上下文中先声明一个不限定作用域的`enum`名字，然后再声明一个同名的限定作用域的`enum`。

----

## 19.4 类成员指针

1. **类成员指针（pointer to member）** 是指可以指向类的非静态成员的指针。
2. 成员指针的类型囊括了类的类型以及成员的类型。
3. 当初始化一个这样的指针时，我们令其指向类的某个成员，但是不指定该成员所属的对象；直到使用成员指针时，才提供成员所属的对象。

### 19.4.1 数据成员指针

### 19.4.2 成员函数指针

### 19.4.3 将成员函数用作可调用对象  

----

## 19.5 嵌套类

----

## 19.6 `union`：一种节约空间的类

----

## 19.7 局部类

----

## 19.8 固有的不可移植的特性

### 19.8.1 位域

### 19.8.2 `volatile`限定符

### 19.8.3 链接指示：`extern "C"`
