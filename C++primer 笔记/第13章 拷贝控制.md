# 第13章 拷贝控制

1. **拷贝构造函数(copy constructor)** 和 **移动构造函数(move constructor)** 定义了当用同类型的另一个对象初始化本对象时做什么。
2. **拷贝赋值运算符(copy-assignment operator)** 和 **移动赋值运算符(move-assignment operator)** 定义了将一个对象赋予同类型的另一个对象时做什么。
3. **析构函数(destructor)** 定义了当此类型对象销毁时做什么。
4. 如果一个类没有定义这些拷贝控制成员，编译器会自动为它定义缺失的操作。

## 13.1 拷贝、赋值与销毁

### 13.1.1 拷贝构造函数

1. 如果一个构造函数的第一个参数是自身类类型的引用，且任何额外参数都有默认值，则此构造函数是拷贝构造函数：

```c++
class Foo(){
public:
    Foo();           // 默认构造函数
    Foo(const Foo&); // 拷贝构造函数
    // ...
}
```

2. 如果我们没有为一个类定义拷贝构造函数，即使我们定义了其他构造函数，编译器也会为我们合成一个拷贝构造函数。从给定对象中依次将每个非 `static` 成员拷贝到正在创建的对象中。
3. 每个成员的类型决定了它如何拷贝：对类类型的成员会使用其拷贝构造函数来拷贝，内置类型的成员则直接拷贝。

```c++
class Sales_data{
public:
    Sales_data(const Sales_data&);
    // ... ...

private:
    std::string bookNo;
    int units_sold = 0;
    double revenue = 0.0;
}

// 自己定义，或让编译器合成：
Sales_data::Sales_data(const Sales_data& orig)
    : bookNo(orig.bookNo),          // 使用string的拷贝构造函数
    units_sold(orig.units_sold),    // 直接拷贝
    revenue(orig.revenue)           // 直接拷贝
    {   }  
```

4. 当使用 **直接初始化** 时，实际上是要求编译器使用 **普通** 的函数匹配来选择与我们提供的参数最匹配的构造函数。
5. 当我们使用 **拷贝初始化** 时，要求编译器使用 **拷贝构造函数** 将右侧运算对象拷贝到正在创建的对象中，如果需要的话还要进行类型转换。

```c++
// 直接初始化
string dots(10, ‘.’);
string s(dots);

// 拷贝初始化
string s2 = dots;
string null_book = "9-9-9";
string nines = string(10, '9');
```

6. 拷贝初始化不仅在用 `=` 定义变量时会发生，在下列情况下也会发生：
（1）将一个对象作为实参传递给一个非引用类型的形参
（2）从一个返回类型为非引用类型的函数返回一个对象
（3）用花括号列表初始化一个数组中的元素或一个聚合类中的成员。
7. 如果 **拷贝构造函数的参数** 不是 **引用类型**（而是值类型），则调用永远也不会成功——为了调用拷贝构造函数，我们必须拷贝它的实参，但为了拷贝实参，我们又需要调用拷贝构造函数，如此无限循环。

### 13.1.2 拷贝赋值运算符

1. 重载运算符(overloaded operator)的本质是函数，其名字由 `operator` 关键字后接表示要定义的运算符的符号组成 (比如`operatro=`)。
2. 如果一个运算符是一个成员函数，其左侧运算对象就绑定到隐式的 `this` 参数。对于一个二元运算符，其右侧运算对象作为显示参数传递。
3. 为了与内置类型的赋值保持一直，赋值运算符通常应该返回一个指向其左侧运算对象的引用（连续拷贝时需要：`a = b = c`）。
4. 标准库通常要求保存在容器中的类型要具有赋值运算符，且其返回值是左侧运算对象的引用。

```c++
class Sales_data{
public:
    // ... ...
   Sales_data& operator=(const Sales_data& rhs);

private:
    std::string bookNo;
    int units_sold = 0;
    double revenue = 0.0;
}

Sales_data& Sales_data::operator=(const Sales_data& rhs)
{
    bookNo = rhs.bookNo;            // 调用string::operator=
    units_sold = rhs.units_sold;    // 使用内置类型的赋值
    revenue = rhs.revenue;
    return *this;                   // 返回左侧对象的引用
}

```

### 13.1.3 析构函数

1. 析构函数释放对象使用的资源，并销毁对象的非 `static` 数据成员。
2. 由于析构函数不接受参数，因此不能被重载。对于一个给定类，只会有唯一一个析构函数。
3. 析构过程中首先执行函数体，然后销毁成员。成员按初始化顺序的逆序销毁。
4. 析构函数体自身并不直接销毁成员，成员是在析构函数体之后隐含的析构阶段中被销毁的。
5. 在析构函数中，不存在类似构造函数中初始化列表的东西来控制成员如何销毁，析构部分是隐式的。
6. 销毁类类型的成员需要执行成员自己的析构函数。内置类型没有析构函数，因此销毁内置类型成员什么也不需要做。
7. 隐式销毁一个内置指针类型的成员不会 `delete` 它所指向的对象。（智能指针是类类型，所以在析构阶段被自动销毁时会根据情况`delete`所指的对象。）
8. 当指向一个对象的引用或指针离开作用域时，析构函数不会执行。

### 13.1.4 三/五法则

1. 如果一个类需要自定义析构函数，几乎可以肯定它也需要自定义拷贝赋值运算符和拷贝构造函数。（例如动态分配对象的销毁带来的析构和拷贝问题）
2. 如果一个类需要一个拷贝构造函数，几乎可以肯定它也需要一个拷贝赋值运算符，反之亦然。
3. 然而无论是需要拷贝构造函数还是需要拷贝赋值运算符都不必然意味着也需要析构函数。

### 13.1.5 使用 `=default`

1. 通过将拷贝控制成员定义为 `=default` 来显示地要求编译器生成合成的版本。
2. 在类内用 `=default` 修饰成员的声明时，合成的函数将隐式地声明为内联的。
3. 如果不希望合成的成员是内联函数，应该只对成员的类外定义使用 `=default`。
4. 只能对具有合成版本的成员函数使用 `=default` （即默认构造函数或拷贝构造函数）。

```c++
class Sales_data{
public:
    Sales_data() = default;         // 内联
    Sales_data(const Sales_data&);  // 外联
}
Sales_data::Sales_data(const Sales_data&) = default;
```

### 13.1.6 阻止拷贝

1. 新标准下，可以通过将拷贝构造函数和拷贝赋值运算符定义为 **删除的函数(deleted function)** 来阻止拷贝。
2. 与 `=default` 不同，`=delete` 必须出现在函数第一次声明的时候。编译器需要知道一个函数是删除的，以便禁止试图使用它的操作。
3. 一个默认的成员只影响为这个成员而生成的代码，因此 `=default` 直到编译器生成代码时才需要。
4. 与 `=default` 的另一个不同之处是，我们可以对任何函数指定 `=delete` ，相对的我们只能对编译器可以合成的默认构造函数或拷贝控制成员使用 `=default`。

```c++
struct NoCopy{
    NoCopy() = default;            // 使用合成的默认构造函数
    NoCopy(const NoCopy&) = delete;             // 阻止拷贝
    NoCopy &operator=(const NoCopy&) = delete;  // 阻止赋值
    ~NoCopy() = default;               // 使用合成的析构函数
    // 其他成员... ...
};
```

5. 析构函数不能是删除的成员，否则无法销毁类型的对象了。
6. 对于删除了析构函数的类型，虽然不能直接定义这种类型的变量和成员，但可以动态分配这种类型的对象。但是不能释放这些对象。
7. 对于析构函数已删除的类型，不能定义该类型的变量或释放指向该类型动态分配对象的指针。

```c++
struct NoDtor{
    NoDtor() = default;     // 使用合成默认构造函数
    ~NoDtor() = delete;     // 不能销毁该类型的对象了
};
NoDtor nd;  // 错误：NoDtor的析构函数是删除的
NoDtor* p = new NoDtor();   // 正确：但我们不能delete p
delete p;   // 错误：NoDtor的析构函数是删除的
```

8. 本质上，当不可能拷贝、赋值或销毁类的成员时，类的合成拷贝控制成员就被定义为删除的。
9. 希望阻止拷贝的类应该使用 `=delete` 来定义它们自己的拷贝构造函数和拷贝赋值运算符，而不应该将它们声明为 `private`的（旧标准时使用的方法）。

----

## 13.2 拷贝控制和资源管理

### 13.2.1 行为像值的类

### 13.2.2 定义行为像指针的类

----

## 13.3 交换操作

----

## 13.4 拷贝控制实例

----

## 13.5 动态内存管理类

----

## 13.6 对象移动

### 13.6.1 右值引用

### 13.6.2 移动构造函数和移动赋值运算符

### 13.6.3 右值引用和成员函数 
