# 第13章 拷贝控制

1. **拷贝构造函数(copy constructor)** 和 **移动构造函数(move constructor)** 定义了当用同类型的另一个对象初始化本对象时做什么。
2. **拷贝赋值运算符(copy-assignment operator)** 和 **移动赋值运算符(move-assignment operator)** 定义了将一个对象赋予同类型的另一个对象时做什么。
3. **析构函数(destructor)** 定义了当此类型对象销毁时做什么。
4. 如果一个类没有定义这些拷贝控制成员，编译器会自动为它定义缺失的操作。

## 13.1 拷贝、赋值与销毁

### 13.1.1 拷贝构造函数

1. 如果一个构造函数的第一个参数是自身类类型的引用，且任何额外参数都有默认值，则此构造函数是拷贝构造函数：

```c++
class Foo(){
public:
    Foo();           // 默认构造函数
    Foo(const Foo&); // 拷贝构造函数
    // ...
}
```

2. 如果我们没有为一个类定义拷贝构造函数，即使我们定义了其他构造函数，编译器也会为我们合成一个拷贝构造函数。从给定对象中依次将每个非 `static` 成员拷贝到正在创建的对象中。
3. 每个成员的类型决定了它如何拷贝：对类类型的成员会使用其拷贝构造函数来拷贝，内置类型的成员则直接拷贝。

```c++
class Sales_data{
public:
    Sales_data(const Sales_data&);
    // ... ...

private:
    std::string bookNo;
    int units_sold = 0;
    double revenue = 0.0;
}

// 自己定义，或让编译器合成：
Sales_data::Sales_data(const Sales_data& orig)
    : bookNo(orig.bookNo),          // 使用string的拷贝构造函数
    units_sold(orig.units_sold),    // 直接拷贝
    revenue(orig.revenue)           // 直接拷贝
    {   }  
```

4. 当使用 **直接初始化** 时，实际上是要求编译器使用 **普通** 的函数匹配来选择与我们提供的参数最匹配的构造函数。
5. 当我们使用 **拷贝初始化** 时，要求编译器使用 **拷贝构造函数** 将右侧运算对象拷贝到正在创建的对象中，如果需要的话还要进行类型转换。

```c++
// 直接初始化
string dots(10, ‘.’);
string s(dots);

// 拷贝初始化
string s2 = dots;
string null_book = "9-9-9";
string nines = string(10, '9');
```

6. 拷贝初始化不仅在用 `=` 定义变量时会发生，在下列情况下也会发生：
（1）将一个对象作为实参传递给一个非引用类型的形参
（2）从一个返回类型为非引用类型的函数返回一个对象
（3）用花括号列表初始化一个数组中的元素或一个聚合类中的成员。
7. 如果 **拷贝构造函数的参数** 不是 **引用类型**（而是值类型），则调用永远也不会成功——为了调用拷贝构造函数，我们必须拷贝它的实参，但为了拷贝实参，我们又需要调用拷贝构造函数，如此无限循环。

### 13.1.2 拷贝赋值运算符

1. 重载运算符(overloaded operator)的本质是函数，其名字由 `operator` 关键字后接表示要定义的运算符的符号组成 (比如`operatro=`)。
2. 如果一个运算符是一个成员函数，其左侧运算对象就绑定到隐式的 `this` 参数。对于一个二元运算符，其右侧运算对象作为显示参数传递。
3. 为了与内置类型的赋值保持一直，赋值运算符通常应该返回一个指向其左侧运算对象的引用（连续拷贝时需要：`a = b = c`）。
4. 标准库通常要求保存在容器中的类型要具有赋值运算符，且其返回值是左侧运算对象的引用。

```c++
class Sales_data{
public:
    // ... ...
   Sales_data& operator=(const Sales_data& rhs);

private:
    std::string bookNo;
    int units_sold = 0;
    double revenue = 0.0;
}

Sales_data& Sales_data::operator=(const Sales_data& rhs)
{
    bookNo = rhs.bookNo;            // 调用string::operator=
    units_sold = rhs.units_sold;    // 使用内置类型的赋值
    revenue = rhs.revenue;
    return *this;                   // 返回左侧对象的引用
}

```

### 13.1.3 析构函数

### 13.1.4 三/五法则

### 13.1.5 使用=default

### 13.1.6 阻止拷贝

----

## 13.2 拷贝控制和资源管理

### 13.2.1 行为像值的类

### 13.2.2 定义行为像指针的类

----

## 13.3 交换操作

----

## 13.4 拷贝控制实例

----

## 13.5 动态内存管理类

----

## 13.6 对象移动

### 13.6.1 右值引用

### 13.6.2 移动构造函数和移动赋值运算符

### 13.6.3 右值引用和成员函数 
