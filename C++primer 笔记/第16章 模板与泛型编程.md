# 第16章 模板与泛型编程

----

## 16.1 定义模板

### 16.1.1 函数模板

1. 我们可以定义一个通用的**函数模板（function template）**，而不是为每个类型都定义一个新函数。一个函数模板就是一个公式，可用来生成针对特定类型的函数版本。
2. 模板定义以关键字`template`开始，后跟一个**模板参数列表（template parameter list）**，模板参数列表不能为空。

```c++
template <typename T>
int compare(const T& v1, const T& v2)
{
    if(v1 < v2) return -1;
    if(v1 > v2) return 1;
    return 0;
}
```

3. 编译器用推断出的模板参数来为我们**实例化（instantiate）**一个特定版本的函数。使用模板实参代替对应的模板参数来创建出模板的一个新"实例"。
4. 我们可以将**类型参数（type parameter）**看作类型说明符，就像内置类型或类类型说明符一样使用。
5. 类型参数可以用来指定返回类型或函数的参数类型，以及在函数体内用于变量声明或类型转换：

```c++
// 类型参数为 T
template <typename T> T foo(T* p)
{
    T tmp = *p;
    // ... 
    return tmp;
}
```

6. 除了定义类型参数，还可以在模板中定义**非类型参数（nontype parameter）**。一个非类型参数表示一个值而非一个类型。通过一个**特定的类型名**而非关键字`class`或`typename`来指定非类型参数。
7. 当一个模板被实例化时，非类型参数被一个用户提供的或编译器推断出的值所代替。这些值必须是常量表达式，从而允许编译器在编译时实例化模板。
8. 一个非类型参数可以是一个整型，或者是一个指向对象或函数类型的指针或（左值）引用。
9. 绑定到非类型整型参数的实参必须是一个常量表达式。绑定到指针或引用的非类型参数的实参必须具有静态的生存期。
10. 不能用一个普通（非`static`）局部变量或动态对象作为指针或引用非类型模板参数的实参。指针参数也可以用`nullptr`或一个值为0的常量表达式来实例化。

```c++
template <unsigned N, unsigned M>
int compare(const char (&p1)[N], const char (&p2)[M])
{
    return strcmp(p1, p2);
}

// 调用模板：
compare("hi", "mom");

// 模板将会实例化成：
int compare(const char (&p1)[3], const char (&p2)[4])
```

11. 模板程序应该尽量减少对实参类型的要求。
12. 函数模板和类模板成员函数的定义通常放在头文件中。
13. 大多数编译错误在实例化期间报告。
14. 保证传递给模板的实参支持模板所要求的操作，以及这些操作在模板中能正确工作，是调用者的责任。

### 16.1.2 类模板

1. **类模板（class template）是用来生成类的蓝图的。
2. 与函数模板的不同之处是，编译器不能为类模板推断模板参数类型。为了使用类模板，我们必须在模板名后的尖括号中提供额外信息-用来代替模板参数的模板实参列表。
3. 使用模板时，需要提供显式模板实参（explicit template argument）列表作为额外信息，它们被绑定到模板参数。编译器使用这些模板参数来实例化特定的类。

```c++
template <typename T> class Blob {
public:
    Blob();
    Blob(std::initializer_list<T> il);
    // ... ...
private:
    std::shared_ptr<std::vector<T>> data;
    // ... ...
}

Blob<int> ia;               // 空Blob<int>
Blob<int> ia2 = {0, 1, 2}   // 有3个元素的Blob<int>

// 编译器会实例化出一个与下面定义等价的类：
template <> class Blob<int> {
public:
    Blob();
    Blob(std::initializer_list<int> il);
    // ... ...
private:
    std::shared_ptr<std::vector<int>> data;
    // ... ...
}
```

4. 一个类模板的每个实例都形成一个独立的类。类型`Blob<string>`与任何其他的`Blob`类型都没有关联，也不会对其他任何`Blob`类型的成员有特殊访问权限。
5. 默认情况下，对于一个实例化了的类模板，其成员只有在使用时才被实例化。这一特征是的即使某种类型不能完全符合模板操作的要求，我们仍然能用该类型实例化类。
6. 在类模板自己的作用域内，可以直接使用模板名而不提供实参，编译器处理模板自身的引用时就好像我们已经提供了与模板参数匹配的实参一样。
7. 当我们在类模板外定义其他成员时，必须记住，我们并不在类的作用域中，直到遇到类名才表示进入类的作用域。
8. 当一个类包含一个友元声明时，类与友元各自是否是模板是相互无关的。
9. 如果一个类模板包含一个非模板友元，则友元被授权可以访问所有模板实例。如果友元自身是模板，类可以授权给所有友元模板实例，也可以只授权给特定实例。

### 16.1.3 模板参数

### 16.1.4 成员模板

### 16.1.5 控制实例化

### 16.1.6 效率与灵活性

----

## 16.2 模板实参推断

### 16.2.1 类型转换与模板类型参数

### 16.2.2 函数模板显式实参

### 16.2.3 尾置返回类型与类型转换

### 16.2.4 函数指针和实参推断

### 16.2.5 模板实参推断和引用

### 16.2.6 理解 std::move

### 16.2.7 转发

----

## 16.3 重载与模板

----

## 16.4 可变参数模板

### 16.4.1 编写可变参数函数模板

### 16.4.2 包扩展

### 16.4.3 转发参数包

----

## 16.5 模板特例化
