# 第3章 字符串、向量和数组

## 3.1 命名空间的 `using` 声明

1. 位于头文件的代码，一般不应该使用 `using` 声明。

----

## 3.2 标准库类型 `string`

### 3.2.1 定义和初始化 `string` 对象

1. 拷贝初始化 *copy initialization*
2. 直接初始化 *direct initialization*

### 3.2.2 `string` 对象上的操作

1. `string` 的 `size()` 返回的是一个 `string::size_type` 类型的值，如果表达式中已经有了 `size()` 函数据就不要再使用 `int` 了，这样可以避免混用 `int` 和 `unsigned` 可能带来的问题。
2. 当把 `string` 对象和字符字面值及字符串字面值混在一条语句中使用时，必须确保每个加法运算符（+）的两侧运算对象至少有一个是string：

```c++
string s1 = "hello" + ".";          // 错误

string s2 = "world";
string s3 = "hello" + "," + s2;     // 错误
```

3. 为了兼容 C，C++ 中的字符串字面值并不是标准库类型 `string` 的对象。

### 3.2.3 处理 `string` 对象中的字符

1. C++ 标准库兼容了 C 语言的标准库。C 语言的头文件形式是 *name*.h, C++ 则将这些文件命名为 *cname*。
2. 在名为 *cname* 的头文件中定义的名字从属于命名空间 `std`，而定义在名为 .h 的头文件中的则不然。

----

## 3.3 标准库类型 `vector`

1. 可以将模板看作为编译器生成类或函数编写的一份说明。
2. 编译器根据模板创建类或函数的过程叫做 *实例化 instantiation*。
3. 因为引用不是对象，所以不存在包含引用的 `vector`。

### 3.3.1 定义和初始化 `vector` 对象

1. 列表初始化 `vector` 过程会尽可能地把花括号内的值当成是元素初始值的列表来处理，只有当无法执行列表初始化时才会考虑其他初始化方式。确定无法执行列表初始化后，编译器会尝试用默认值初始化 `vector` 对象。

```c++
vector<int>     v1{10};             // v1有一个元素，该元素为10
vector<string>  v2{10};          // v2有10个默认初始化的元素。

vector<int>     v3{10, 1};          // v3有2个元素，值分别是10和1
vector<string>  v4{10, "hi"};    // v4有10个值为 "hi" 的元素
```

### 3.3.2 向 `vector` 对象中添加元素

1. 在定义 `vector` 对象的时候先设定其大小，可能性能还会降低。除非所有的元素的值都是一样时效率才会高。

### 3.3.3 其他 `vector` 操作



----

## 3.4 迭代器介绍

### 3.4.1 使用迭代器


### 3.4.2 迭代器运算

----

## 3.5 数组

### 3.5.1 定义和初始化内置数组


### 3.5.2 访问数组元素


### 3.5.3 指针和数组


### 3.5.4 C风格字符串


### 3.5.5 于旧代码的接口

----

## 3.6 多维数组

