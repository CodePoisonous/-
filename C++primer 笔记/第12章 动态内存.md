# 第12章 动态内存

1. *静态内存* 用来保存局部 `static` 对象、类 `static` 数局成员以及定义在任何函数之外的变量。
2. *栈内存* 用来保存定义在函数内的非 `static` 对象。
3. 分配在 *静态* 或 *栈* 内存中的对象由编译器自动创建和销毁。
4. 对于 *栈对象*，仅在其定义的程序块运行时才存在。
5. `static` 对象在使用之前分配，在程序结束时销毁。
6. 程序用 *堆（heap）* 来存储 *动态分配（dynamically allocate）* 的对象（程序运行时分配的对象）。动态对象的生存期由程序来控制，当动态对象不再使用时，我们的代码必须显式地销毁它们。
7. 虽然使用动态内存有时是必要的，但是正确地管理动态内存是非常棘手的。

## 12.1 动态内存与智能指针

1. `new` 在动态内存中为对象分配空间并返回一个指向该对象的指针，我们可以选择对对象进行初始化。
2. `delete` 接受一个动态对象的指针，销毁该对象，并释放与之关联的内存。
3. 忘记释放内存，会产生内存泄漏。
4. 在尚有指针引用内存的情况下释放了内存，会产生引用非法内存的指针。
5. `shared_ptr` 允许多个指针指向同一个对象。
6. `unique_ptr` 则“独占”所指向的对象。
7. `weak_ptr` 是一个伴随类，一种弱引用，指向 `shared_ptr` 所管理的对象。

### 12.1.1 `shared_ptr`类

1. 默认初始化的智能指针中保存着一个空指针。
2. `p = q`：p 和 q 都是 `shared_ptr`，此操作会递减 p 指向对象的引用计数，递增 q 原来指向对象的引用计数。若 p 的引用计数变为 0，则将其管理的原内存释放。
3. `p.use_count()` 返回与 p 共享对象的智能指针数量，可能很慢，主要用于调试。
4. 到底是用一个计数器还是其他数据结构来记录有多少指针共享对象，完全由标准库的具体实现来决定。关键是智能指针能记录有多少个 `shared_ptr` 指向相同的对象，并能在恰当的时候自动释放对象。
5. `shared_ptr` 在无用之后仍然保留的一种可能情况是：将 `shared_ptr` 存放在一个容器中，而后不再需要全部元素，而只使用其中一部分。（在此情况下，要记得用 `erase` 删除不再需要的那些元素。）

### 12.1.2 直接管理内存


### 12.1.3 `shared_ptr` 和 `new` 结合使用


### 12.1.4 智能指针和异常


### 12.1.5 `unique_ptr`


### 12.1.6 `weak_ptr`

----

## 12.2 动态数组

### 12.2.1 `new` 和数组


### 12.2.2 `allocator` 类


----

## 12.3 使用标准库：文本查询程序

### 12.3.1 文本查询程序设计


### 12.3.2 文本查询程序类的定义
