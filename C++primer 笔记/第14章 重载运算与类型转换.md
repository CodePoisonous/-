# 第14章 重载运算与类型转换

## 14.1 基本概念

1. **重载运算符**是具有特殊名字的函数：由关键字 `operator` 和其后要定义的运算符号共同组成。包含返回类型、参数列表以及函数体。
2. 除了重载的函数调用运算符 `operator()` 之外，其他重载运算符不能含有默认实参。
3. 当一个重载的运算符是成员函数时，`this` 绑定到左侧运算对象。成员运算符函数的（显式）参数数量比运算对象的数量少一个。
4. 无法改变**内置类型运算对象**的符号含义。
5. 只能重载已有的运算符，而**无权发明新的运算符号**。
6. 重载的运算符其**优先级**和**结合律**与对应的内置运算符保持一致。

7. 直接调用一个重载的运算符函数：

```c++
// 等价的表达
data1 + data2;
operator+(data1, data2);
data1.operator+(data2);
```

8. 通常情况下，不应该重载逗号`，`、取地址`&`、逻辑与`&&` 和逻辑或`||` 运算符。会无法保留求值顺序和/或短路属性。
9. 建议只有当操作的含义对于用户来说清晰明了时才使用运算符。如果用户对运算符可能有几种不同的理解，则使用这样的运算符将产生二义性。

----

## 14.2 输入和输出运算符

### 14.2.1 重载输出运算符 `<<`

1. 通常，输出运算符应该主要负责打印对象的内容而非控制格式，输出运算符不应该打印换行符。
2. 如果希望为类自定义IO运算符，则必须将其定义成非成员函数。IO运算符通常需要读写类的非公有数据成员，所以IO运算符一般被声明为友元。

### 14.2.2 重载输入运算符 `>>`

1. 输入运算符必须处理输入可能失败的情况，而输出运算符不需要。
2. 当读取操作发生错误时，输入运算符应该负责从错误中恢复。

----

## 14.3 算术与关系运算符

1. 如果类同时定义了算术运算符和相关的复合赋值运算符，则通常情况下应该使用复合赋值来实现算术运算符。

### 14.3.1 相等运算符 `==`

1. 如果某个类在逻辑上有相等性的含义，则该类应该定义 `operator==`，这样做可以使得用户更容易使用标准库算法来处理这个类。

### 14.3.2 关系运算符 `<` `>` `<=` `>=`

1. 如果存在唯一一种逻辑可靠的 < 定义，则应该考虑为这个类定义 < 运算符。如果类同时还包含 ==，则当且仅当 < 的定义和 == 产生的结果一致时才定义 < 运算符。

----

## 14.4 赋值运算符 `=`

1. 可以重载赋值运算符。不论形参的类型是什么，赋值运算符都必须定义为成员函数。
2. 赋值运算符必须定义成类的成员，复合赋值运算符通常情况下也应该这样做。这两类运算符都应该返回左侧运算对象的引用。

----

## 14.5 下标运算符 `[]`

1. 下标运算符必须是成员函数。
2. 如果一个类包含下标运算符，则它通常会定义两个版本：一个返回普通引用，另一个是类的常量成员并且返回常量引用。

```c++
class StrVec{
public:
    // 普通版本
    std::string& operator[](std::size_t n)
        { return elements[n]; }
    // 常量成员，返回常量引用
    const std::string& operator[](std::size_t n) const
        { return elements[n]; }

private:
    std::string *elements;
}
```

----

## 14.6 递增和递减运算符 `++` `--`

1. 定义递增和递减运算符的类应该同时定义前置版本和后置版本。这些运算符通常应该被定义成类的成员。
2. 为了与内置版本保持一致，前置运算符应该返回递增或递减后对象的引用。
3. 后置版本接受一个额外的（不被使用）int 类型的形参。让编译器区分前后置版本。
4. 为了与内置版本保持一致，后置运算符应该返回对象的原值（递增或递减之前的值，需额外拷贝一份原值的副本），返回的形式是一个值而非引用。

```c++
class StrBlobPtr{
public:
    // 前置版本
    StrBlobPtr& operator++();
    StrBlobPtr& operator--();

    // 后置版本
    // 不会用到int形参，无须为其命名
    StrBlobPtr operator++(int);
    StrBlobPtr operator--(int);
}

StrBlobPtr p;
// 前置版本调用
++p;
p.operator++();
// 后置版本调用
p++;
p.operator++(0);
```

----

## 14.7 成员访问运算符 `*` `->`

1. 箭头运算符必须是类的成员。解引用运算符通常也是类的成员，尽管并非必须如此。
2. 重载的箭头运算符必须返回类的指针或者自定义了箭头运算符的某个类的对象。（建议到书本中查看此处对应的详细解释）

----

## 14.8 函数调用运算符 `()`

### 14.8.1 lambda是函数对象

### 14.8.2 标准库定义的函数对象

### 14.8.3 可调用对象与function

----

## 14.9 重载、类型转换与运算符

### 14.9.1 类型转换运算符

### 14.9.2 避免有二义性的类型转换

### 14.9.3 函数匹配与重载运算符