# 第15章 面向对象程序设计

## 15.1 OOP：概述

1. **面向对象程序设计**(object-oriented programming)的核心思想是：**数据抽象**、**继承**和**动态绑定**。
2. 数据抽象：可以将类的接口与实现分离。
3. 继承（inheritance）：可以定义相似的类型并对其相似关系建模。
4. 动态绑定(dynamic binding)：可以在一定程度上忽略相似类型的区别，而以统一的方式使用它们的对象。
5. 动态绑定有时又被称为**运行时绑定(run-time binding)**
6. 在C++中，当使用基类的引用（或指针）调用一个虚函数时将发生动态绑定。

----

## 15.2 定义基类和派生类

### 15.2.1 定义基类

1. 基类通常都应该定义一个**虚析构函数**，即使该函数不执行任何实际操作也是如此。
2. c++中，基类必须将它的两种成员函数区分开：一种是基类希望其派生类进行覆盖的函数（虚函数）。一种是基类希望派生类直接继承而不要改变的函数。
3. 成员函数如果没被声明为虚函数，则其解析过程发生在**编译**时而非**运行**时。

### 15.2.2 定义派生类

1. **访问说明符**（public、protected和private）的作用是：控制派生类从基类继承而来的成员是否对派生类的用户可见。
2. 如果派生类没有覆盖其基类中的某个虚函数，则该虚函数的行为类似于其他的普通成员，派生类会直接继承其在基类中的版本。
3. c++标准并没有明确规定派生类的对象在内存中如何分布。一个对象中，继承自基类的部分和派生类自定义的部分在内存中不一定是连续存储的。
4. 尽管在派生类对象中含有从基类继承而来的成员，但是派生类并不能直接初始化这些成员。和其他创建了基类对象的代码一样，派生类也必须使用基类的构造函数来初始化它的基类部分。
5. 如果基类定义了一个静态成员，则在整个继承体系中只存在该成员的唯一定义。不论从基类中派生出多少个派生类，对于每个静态成员来说都只存在唯一的实例。
6. 如果我们想将某个类用作基类，则该类必须已经定义而非仅仅声明。
7. 一个类不能派生它本身。
8. 最终的派生类将包含它的直接基类的子对象以及每个间接基类的子对象。
9. c++11新标准提供了一种防止继承发生的方法，即在类名后跟一个关键字 `final`。

### 15.2.3 类型转换与继承

1. 我们可以将基类的指针或引用绑定到派生类对象上。当使用基类的引用（或指针）时，实际上我们不清楚该引用（或指针）所绑定对象的真实类型。
2. 智能指针类也支持派生类向基类的类型转换，可以将一个派生类对象的指针存储在一个基类的智能指针内。
3. 当使用存在继承关系的类型时，必须将一个变量或其他表达式的**静态类型（static type）**与该表达式表示对象的**动态类型（dynamic type）**区分开来：
(1) 表达式的静态类型在编译时总是已知的，它是变量声明时的类型或表达式生成的类型。
(2) 动态类型则是变量或表达式表示的内存中的对象的类型。动态类型直到运行时才可知。
(3) 如果表达式既不是引用也不是指针，则它的动态类型永远与静态类型一致。
4. 不存在从基类向派生类的**隐式**类型转换。

```c++
class Quote {...}
class Bulk_quote : public Quote {...}

Quote base;                  // 基类对象
Bulk_quote derived;          // 派生类对象

Quote* baseP1 = &derived;    // 正确：基类指针绑派生类对象
Quote& baseRef = derived;    // 正确：基类引用绑派生类对象

Bulk_quote* bulkP1 = &base;  // 错误：不能派生类指针绑基类对象
Bulk_quote& bulkRef = base;  // 错误：不能派生类引用绑基类对象

Quote* baseP2 = &derived;    // 正确：基类指针绑派生类对象
Bulk_quote* bulkP2 = baseP2; // 错误：不能将基类转换成派生类
```

5. 编译器在编译时无法确定某个特定的转换在运行时是否安全，因为编译器只能通过检查指针或引用的静态类型来推断该转换是否合法。但我们可以使用**显式**的方式进行类型转换：
(1) 如果在基类中含有一个或多个虚函数，我们可以使用 `dynamic_cast` 请求一个类型转换，该转换的安全检查将在运行时执行。
(2)如果我们已知某个基类向派生类的转换是安全的，则可以使用 `static_cast` 来强制覆盖掉编译器的检查工作。
6. 当我们用一个派生类对象为一个基类对象初始化或赋值时，只有该派生类对象中的基类部分会被拷贝、移动或赋值，它的派生类部分将被忽略掉。

```c++
Bulk_quote bulk;    // 派生类对象
Quote item(bulk);   // 使用Quote::Quote(const Quote&)构造函数
item = bulk;        // 调用Quote::operator=(const Quote&)
```

----

## 15.3 虚函数

----

## 15.4 抽象基类

----

## 15.5 访问控制与继承

----

## 15.6 继承中的类作用域

----

## 15.7 构造函数与拷贝控制

----

### 15.7.1 虚析构函数

### 15.7.2 合成拷贝控制与继承

### 15.7.3 派生类的拷贝控制成员

### 15.7.4 继承的构造函数

----

## 15.8 容器与继承

### 15.8.1 编写 `Basket` 类

----

## 15.9 文本查询程序再探

### 15.9.1 面向对象的解决方案

### 15.9.2 `Query_base` 类和 `Query` 类

### 15.9.3 派生类

### 15.9.4 `eval` 函数
