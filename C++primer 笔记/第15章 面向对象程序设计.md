# 第15章 面向对象程序设计

## 15.1 OOP：概述

1. **面向对象程序设计**(object-oriented programming)的核心思想是：**数据抽象**、**继承**和**动态绑定**。
2. 数据抽象：可以将类的接口与实现分离。
3. 继承（inheritance）：可以定义相似的类型并对其相似关系建模。
4. 动态绑定(dynamic binding)：可以在一定程度上忽略相似类型的区别，而以统一的方式使用它们的对象。
5. 动态绑定有时又被称为**运行时绑定(run-time binding)**
6. 在C++中，当使用基类的引用（或指针）调用一个虚函数时将发生动态绑定。

----

## 15.2 定义基类和派生类

### 15.2.1 定义基类

1. 基类通常都应该定义一个**虚析构函数**，即使该函数不执行任何实际操作也是如此。
2. c++中，基类必须将它的两种成员函数区分开：一种是基类希望其派生类进行覆盖的函数（虚函数）。一种是基类希望派生类直接继承而不要改变的函数。
3. 成员函数如果没被声明为虚函数，则其解析过程发生在**编译**时而非**运行**时。

### 15.2.2 定义派生类

1. **访问说明符**（public、protected和private）的作用是：控制派生类从基类继承而来的成员是否对派生类的用户可见。
2. 如果派生类没有覆盖其基类中的某个虚函数，则该虚函数的行为类似于其他的普通成员，派生类会直接继承其在基类中的版本。
3. c++标准并没有明确规定派生类的对象在内存中如何分布。一个对象中，继承自基类的部分和派生类自定义的部分在内存中不一定是连续存储的。
4. 尽管在派生类对象中含有从基类继承而来的成员，但是派生类并不能直接初始化这些成员。和其他创建了基类对象的代码一样，派生类也必须使用基类的构造函数来初始化它的基类部分。
5. 如果基类定义了一个静态成员，则在整个继承体系中只存在该成员的唯一定义。不论从基类中派生出多少个派生类，对于每个静态成员来说都只存在唯一的实例。
6. 如果我们想将某个类用作基类，则该类必须已经定义而非仅仅声明。
7. 一个类不能派生它本身。
8. 最终的派生类将包含它的直接基类的子对象以及每个间接基类的子对象。
9. c++11新标准提供了一种防止继承发生的方法，即在类名后跟一个关键字 `final`。

### 15.2.3 类型转换与继承

1. 我们可以将基类的指针或引用绑定到派生类对象上。当使用基类的引用（或指针）时，实际上我们不清楚该引用（或指针）所绑定对象的真实类型。
2. 智能指针类也支持派生类向基类的类型转换，可以将一个派生类对象的指针存储在一个基类的智能指针内。
3. 当使用存在继承关系的类型时，必须将一个变量或其他表达式的**静态类型（static type）**与该表达式表示对象的**动态类型（dynamic type）**区分开来：
(1) 表达式的静态类型在编译时总是已知的，它是变量声明时的类型或表达式生成的类型。
(2) 动态类型则是变量或表达式表示的内存中的对象的类型。动态类型直到运行时才可知。
(3) 如果表达式既不是引用也不是指针，则它的动态类型永远与静态类型一致。
4. 不存在从基类向派生类的**隐式**类型转换。

```c++
class Quote {...}
class Bulk_quote : public Quote {...}

Quote base;                  // 基类对象
Bulk_quote derived;          // 派生类对象

Quote* baseP1 = &derived;    // 正确：基类指针绑派生类对象
Quote& baseRef = derived;    // 正确：基类引用绑派生类对象

Bulk_quote* bulkP1 = &base;  // 错误：不能派生类指针绑基类对象
Bulk_quote& bulkRef = base;  // 错误：不能派生类引用绑基类对象

Quote* baseP2 = &derived;    // 正确：基类指针绑派生类对象
Bulk_quote* bulkP2 = baseP2; // 错误：不能将基类转换成派生类
```

5. 编译器在编译时无法确定某个特定的转换在运行时是否安全，因为编译器只能通过检查指针或引用的静态类型来推断该转换是否合法。但我们可以使用**显式**的方式进行类型转换：
(1) 如果在基类中含有一个或多个虚函数，我们可以使用 `dynamic_cast` 请求一个类型转换，该转换的安全检查将在运行时执行。
(2)如果我们已知某个基类向派生类的转换是安全的，则可以使用 `static_cast` 来强制覆盖掉编译器的检查工作。
6. 当我们用一个派生类对象为一个基类对象初始化或赋值时，只有该派生类对象中的基类部分会被拷贝、移动或赋值，它的派生类部分将被忽略掉。

```c++
Bulk_quote bulk;    // 派生类对象
Quote item(bulk);   // 使用Quote::Quote(const Quote&)构造函数
item = bulk;        // 调用Quote::operator=(const Quote&)
```

----

## 15.3 虚函数

1. OOP的核心思想是**多态性（polymorphism）**。引用或指针的静态类型与动态类型不同这一事实正是c++支持多态性的根本所在。
2. 当且仅当对通过指针或引用调用虚函数时，才会在运行时解析该调用，也只有在这种情况下对象的动态类型才有可能与静态类型不同。
3. 基类中的虚函数在派生类中隐含地也是一个虚函数。当派生类覆盖了某个虚函数时，该虚函数在基类中的形参必须与派生类中的形参严格匹配。返回值也是如此。
4. 上述规定有个例外：当类的虚函数返回类型是类本身的指针或引用时，上述规则无效。也就是说，如果D由B派生得到，则基类的虚函数可以返回B*而派生类的对于函数可以返回D*，只不过这样的返回类型要求从D到B的类型转换是可访问的。
5. 派生类如果定义了一个函数与基类中虚函数的名字相同但是**形参列表不同**，这是合法的。这时派生类的函数并不会覆盖调基类中的版本。但是就实际编程习惯来说这样做往往意味着该情况是不小心将虚函数的**形参列表搞错**了。
6. 我们可以使用 `override` 关键字标记了某个虚函数。但该函数并没有覆盖已存在的虚函数，此时编译器将会报错。
7. 我们还能把某个函数指定为 `final`，之后任何尝试覆盖该函数的操作将引发错误。

```c++
struct B {
    virtual void f1(int) const;
    virtual void f2(); 
    void f3();
    virtual f4() final;
}
struct D1 : public B {
    void f1(int) const override; // 正确：f1与基类中的f1匹配
    void f2(int) override;       // 错误：B没有形如f2(int)的函数
    void f3() override;          // 错误：f3不是虚函数
    void f4() override;          // 错误：f4已经被声明成final
    void f5() override;          // 错误：B没有名为f5的函数
}
```

8. 如果虚函数使用默认实参，则基类和派生类中定义的默认实参最好一致。**如不一致**，无论是基类还是派生类调用该虚函数，**都只会使用基类的默认实参**。
9. 使用**作用域运算符**可以实现对虚函数的调用不进行动态绑定，而是强迫其执行虚函数的某个特定版本。

```c++
double undiscouted = baseP->Quote::net_price(42);
```

10. 通常情况下，只有成员函数（或友元）中的代码才需要使用作用域运算符来回避虚函数机制。
11. 如果一个派生类虚函数需要调用它的基类版本，但是没有使用作用域运算符，则在运行时该调用将被解析为对派生类版本自身的调用，从而导致无限递归。

----

## 15.4 抽象基类

----

## 15.5 访问控制与继承

----

## 15.6 继承中的类作用域

----

## 15.7 构造函数与拷贝控制

### 15.7.1 虚析构函数

### 15.7.2 合成拷贝控制与继承

### 15.7.3 派生类的拷贝控制成员

### 15.7.4 继承的构造函数

----

## 15.8 容器与继承

### 15.8.1 编写 `Basket` 类

----

## 15.9 文本查询程序再探

### 15.9.1 面向对象的解决方案

### 15.9.2 `Query_base` 类和 `Query` 类

### 15.9.3 派生类

### 15.9.4 `eval` 函数
